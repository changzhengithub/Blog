# 原型的理解

面向对象编程，就要理解对象的创建，原型属性、原型链，继承等。
## 构造函数

每个函数都会隐式返回一个return，不明写就返回undefinde，构造函数是通过隐式返回this的，如果通过return返回，返回不是对象就返回this，是对象就取代this返回这个对象。

如下通过构造函数来创建一个对象：
```js
function Person(age) {
  this.age = age;
  this.say = function() {
    console.log(this.age)
  }
}
var person = new Person(18);
person.say(); // 18
```

构造器属性：

当创建一个对象时，这个对象就有了一个构造器属性 `constructor`，该属性实际上是一个指向创建该对象的构造器函数的引用。

```js
function Fn() {
  this.name = 'xxx'
}
var fn = new Fn();
fn.constructor === Fn // true

var obj = {}
obj.constructor
ƒ Object() { [native code] }
```
instanceof操作符：

instanceof操作符可以判断一个对象是否是由某个指定的构造器函数所创建。

```js
function Fn() {
  this.name = 'xxx'
}
var fn = new Fn();
fn instanceof Fn  // true
var obj = {}
obj instanceof Object  // true
obj instanceof Array  // false
```

构造函数的原理就相当于内部有个this变量，属性和方法都挂在这个this上，等到结束时被返回。其实也可以通过一个工厂函数来创建，直接返回一个对象。

new一个对象的过程：

* 创建一个新对象；
* 将构造函数的作用域赋值给新对象（因此this就指向了这个新对象）；
* 执行构造函数中的代码（为这个新对象添加属性和方法）；
* 返回这个新对象。

## 原型属性

通过构造函数来创建对象时，如果每创建一个对象就需要new一下，我们可以使用原型对象来节省空间，把其他属性和方法都挂在原型对象上，这样就不需要每次new来多次创建了。

函数也属于对象，每个函数都有一个prototype原型属性，但只有当做构造函数时才会起作用。

因为原型对象是引用类型，所以，每次创建的对象都是对原型的引用，没有自己的原型副本，所以修改原型对象的属性会同时改变掉。

```js
function Person(name) {
  this.name = name;
}
Person.prototype.name = 'chang';
Person.prototype.talk = function() {
  console.log(this.name);
};

var person = new Person('zhen');
person.name; // zhen
person.talk(); // 'zhen'
```
可以看出实例属性会覆盖原型上的属性，如果要判断一个属性是自身的还是原型属性，可以使用 `hasOwnProperty()`方法

```js
person.hasOwnProperty('name');  // true
```

有时会直接把一个对象赋值给原型，我们可以通过 `isPrototypeOf()` 方法来判断当前对象是否另一个对象的原型。
```js
function Person(name) {
  this.name = name;
}
var obj = {
  age: 18
}
Person.prototype = obj;

var person = new Person('zhen');
// obj是否是person的原型
obj.isPrototypeOf(person); // true
```
## 原型陷阱

看下面代码，对原型对象重新赋值后的变化

```js
function Fn() {
    this.name = 'xxx'
}
Fn.prototype.age = 18

var fn = new Fn();
fn.age // 18
Fn.prototype = {
  class: 1
}

var fn1 = new Fn();
fn.class // undefined 
fn1.age // undefined

fn.constructor === Fn // true
fn1.constructor === Fn // false
```
原型对象是实例之间共享的，但是，如果我们使用一个新的对象重新覆盖之前的原型对象时，就会发现之前的实例对象虽然还能访问覆盖前的原型，但是新的原型无法访问了，新创建的实例对象也无法访问之前的原型了，这是因为实例对象与原型对象之间的连接更换了。但是为什么新的实例对象的`constructor`属性却无法指向构造函数了呢？

这就要事先了解一点知识了，在我们创建构造函数时，该函数就会创建一个`prototype`属性，这属性指向函数的原型对象。默认情况下，原型对象会自动获得一个`constructor`（构造函数）属性，这个属性又指向了之前的构造函数了。

```js
function Person() {}

var person = new Person();

Person.prototype.constructor === Person  // true

person.constructor === Person // true

person.constructor === Person.prototype.constructor // true  继承自原型对象上
```
在new一个实例对象后，该实例对象通过一个神秘链接 `__prote__` 属性继承了原型对象上的属性，所以该实例对象上的`constructor`也是继承自原型对象上的。所以原型对象的替换重写了prototype对象，`constructor`属性变成了新的`constructor`属性（指向Object构造函数）了，也就导致了新创建的实例对象的构造器属性无法指向了构造函数。

解决办法：

重新把原型对象上的`constructor`属性设置到构造函数上来解决这个问题，这也是之后原型实现继承要做的。

```js
Person.prototype.constructor = Person
```
## 原型链


![An image](/img/proto.png)

构造函数的prototype原型对象的constructor属性，直接指向构造函数本身。

每个函数都有一个原型属性，但只有在构造函数时才会生效。

## 继承