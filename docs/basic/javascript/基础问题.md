# 基础问题

## js数据类型

基本类型： Number、String、Boolean、Undefined、Null

引用类型： Object

## Undefined和Null的区别

Null是一个空对象引用，typeof值为object，代表是一个对象，所以最好用于未来可能是对象的值

Undefined表示一个变量没有被声明，或者被声明了但没有被赋值（未初始化）typeof为undefined

## 获取时间戳

``` js
Date.now() === (new Date()).getTime()

(new Date()).getDay() // 获取星期

(new Date()).getDate() // 获取日期
```

## 判断js数据类型

基本类型可以使用`typeof`来进行判断

```js
typeof 'ConardLi'  // string
typeof 123  // number
typeof true  // boolean
typeof Symbol()  // symbol
typeof undefined  // undefined
```

你还可以用它来判断函数类型：

```js
typeof function(){}  // function
```

但当是`null`和引用类型就不能用typeof判断了

```js
typeof null // object
typeof [] // object
typeof {} // object
typeof new Date() // object
typeof /^\d*$/; // object
```
使用`instanceof`来判断

instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。可以用来判断是什么类型。

```js
var obj = {}
var arr = []
obj instanceof Object // true
arr instanceof Object // true
obj instanceof Array // false
arr instanceof Array // true

function(){}  instanceof Object // true
```
可以看出`instanceof`并不是一个很好的选择。

使用 toString 方法

Object对象直接使用，因为其他类型重写了toString，所以要通过call/apply来调用。返回一个类型[Object xxx] 的字符串

```js
var obj = {}
var arr = []
obj.toString() // "[object Object]"
Object.prototype.toString.call(arr) // "[object Array]"
Object.prototype.toString.call('') // "[object String]"
Object.prototype.toString.call(null) // "[object Null]"
Object.prototype.toString.call(1) // "[object Number]"
```

判断是不是数组

``` js
1. Array.isArray(xx) // 判断是不是数组

2. instanceOf操作符 

var obj = {}
var arr = []
obj instanceof Object // true
arr instanceof Object // true
obj instanceof Array // false
arr instanceof Array // true
```


## 什么是作用域

一个包含变量、对象、函数的集合

## for循环

for循环里只有立即执行的表达式才能实时获取每一个i值，通过在外部调用里面的函数或是setTimeOut等延迟执行的都无法获取实时的值，只能获取最后一个值。

## 闭包

简单讲是可以获取其他函数内部作用域的函数

一个函数保留了访问另一个函数作用域的链接

一个函数创建就形成了一个闭包，因为能访问全局作用域。

可以通过return 或者 把函数赋值给全局变量来实现

闭包只保留作用域的访问权，不能访问具体的值。


## new一个对象发生了什么


创建空对象；

var obj = {};

设置新对象的constructor属性为构造函数的名称，设置新对象的__proto__属性指向构造函数的prototype对象；

obj.__proto__ = ClassA.prototype;

使用新对象调用函数，函数中的this被指向新实例对象：

ClassA.call(obj);//{}.构造函数();

如果无返回值或者返回一个非对象值，则将新对象返回；如果返回值是一个新对象的话那么直接直接返回该对象。


## defer和async 异步加载

`script`标签添加`defer`或者`async`属性，脚本就会异步加载。

渲染引擎遇到`defer`或者`async`命令后就开始下载脚本，但不会等待它下载和执行来阻塞进程，和后面的命令会同步进行。

`defer`与`async`的区别是：`defer`要等到其他渲染结束（DOM结构完成，以及其他脚本执行完成），才会执行；`async`是一旦下载完成，渲染引擎就会中断其他命令来执行这个脚本。`defer`是“渲染完再执行”，`async`是“下载完就执行”。

都是和后面命令同步下载，不阻塞进程，但执行时机不一样。

## ready/onload的区别

ready表示文档结构（DOM结构）已经加载完成（不包含图片等非文字媒体文件），和DOMContentLoaded一样。

onload表示页面包含图片等文件在内的所有元素都加载完成。

所以ready要比onload先执行一些。

