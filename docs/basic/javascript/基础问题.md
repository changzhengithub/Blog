# 基础问题

## js数据类型

基本类型： Number、String、Boolean、Undefined、Null

引用类型： Object

## Undefined和Null的区别

Null是一个空对象引用，typeof值为object，代表是一个对象，所以最好用于未来可能是对象的值

Undefined表示一个变量没有被声明，或者被声明了但没有被赋值（未初始化）typeof为undefined

## 获取时间戳

``` js
Date.now() === (new Date()).getTime()

(new Date()).getDay() // 获取星期

(new Date()).getDate() // 获取日期
```

## 判断js数据类型

基本类型可以使用`typeof`来进行判断

```js
typeof 'ConardLi'  // string
typeof 123  // number
typeof true  // boolean
typeof Symbol()  // symbol
typeof undefined  // undefined
```

你还可以用它来判断函数类型：

```js
typeof function(){}  // function
```

但当是`null`和引用类型就不能用typeof判断了

```js
typeof null // object
typeof [] // object
typeof {} // object
typeof new Date() // object
typeof /^\d*$/; // object
```
使用`instanceof`来判断

instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。可以用来判断是什么类型。

```js
var obj = {}
var arr = []
obj instanceof Object // true
arr instanceof Object // true
obj instanceof Array // false
arr instanceof Array // true

function(){}  instanceof Object // true
```
可以看出`instanceof`并不是一个很好的选择。

使用 toString 方法

Object对象直接使用，因为其他类型重写了toString，所以要通过call/apply来调用。返回一个类型[Object xxx] 的字符串

```js
var obj = {}
var arr = []
obj.toString() // "[object Object]"
Object.prototype.toString.call(arr) // "[object Array]"
Object.prototype.toString.call('') // "[object String]"
Object.prototype.toString.call(null) // "[object Null]"
Object.prototype.toString.call(1) // "[object Number]"
```

判断是不是数组

``` js
1. Array.isArray(xx) // 判断是不是数组

2. instanceOf操作符 

var obj = {}
var arr = []
obj instanceof Object // true
arr instanceof Object // true
obj instanceof Array // false
arr instanceof Array // true
```


## 什么是作用域

一个包含变量、对象、函数的集合

## for循环

for循环里只有立即执行的表达式才能实时获取每一个i值，通过在外部调用里面的函数或是setTimeOut等延迟执行的都无法获取实时的值，只能获取最后一个值。

## 闭包

简单讲是可以获取其他函数内部作用域的函数

一个函数保留了访问另一个函数作用域的链接

一个函数创建就形成了一个闭包，因为能访问全局作用域。

可以通过return 或者 把函数赋值给全局变量来实现

闭包只保留作用域的访问权，不能访问具体的值。


## new一个对象发生了什么


创建空对象；

var obj = {};

设置新对象的constructor属性为构造函数的名称，设置新对象的__proto__属性指向构造函数的prototype对象；

obj.__proto__ = ClassA.prototype;

使用新对象调用函数，函数中的this被指向新实例对象：

ClassA.call(obj);//{}.构造函数();

如果无返回值或者返回一个非对象值，则将新对象返回；如果返回值是一个新对象的话那么直接直接返回该对象。


## defer和async 异步加载

`script`标签添加`defer`或者`async`属性，脚本就会异步加载。

渲染引擎遇到`defer`或者`async`命令后就开始下载脚本，但不会等待它下载和执行来阻塞进程，和后面的命令会同步进行。

`defer`与`async`的区别是：`defer`要等到其他渲染结束（DOM结构完成，以及其他脚本执行完成），才会执行；`async`是一旦下载完成，渲染引擎就会中断其他命令来执行这个脚本。`defer`是“渲染完再执行”，`async`是“下载完就执行”。

都是和后面命令同步下载，不阻塞进程，但执行时机不一样。

## ready/onload的区别

ready表示文档结构（DOM结构）已经加载完成（不包含图片等非文字媒体文件），和DOMContentLoaded一样。

onload表示页面包含图片等文件在内的所有元素都加载完成。

所以ready要比onload先执行一些。


## http状态码

http状态码主要分为5种类型：

* 1**	信息反馈，服务器收到请求，需要请求者继续执行操作
* 2**	请求成功，操作被成功接收并处理
* 3**	重定向，需要进一步的操作以完成请求
* 4**	客户端错误，请求包含语法错误或无法完成请求
* 5**	服务器错误，服务器在处理请求的过程中发生了错误

常见的几个状态码：

* 200 请求成功

* 301 永久重定向
* 302 临时重定向

* 400 客户端请求的语法错误，服务器无法理解
* 401 未授权，需要身份验证
* 403 禁止访问 服务器理解请求客户端的请求，但是拒绝执行此请求
* 404 服务器找不到请求的资源（网页），请求路径不对。
* 405 请求方法被禁止。
* 409 服务器请求时发生冲突

* 500 服务器内部错误，无法完成请求。
* 501 服务器不支持请求的功能，无法完成请求。
* 502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。
* 503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。


## 打印&&、||

```js
// 根据判断条件来打印其中某个值，而不是返回两个共同的结果

// 先判断第一个是否为真，为真取第二个，为假取第一个
console.log(true && true) // true
console.log(true && false) // false
console.log(true && 1) // 1
console.log(true && 0) // 0
console.log(false && false) // false
console.log(false && true) // false
console.log(false && 1) // false
console.log(false && 0) // false
console.log(0 && 1) // 0
console.log(1 && 0) // 1

// 有真取真
console.log(true || true) // true
console.log(true || false) // true
console.log(true || 1) // true
console.log(true || 0) // true
console.log(false || true) // true
console.log(false || false) // false
console.log(false || 0) // 0
console.log(false || 1) // 1
console.log(0 || 1) // 1
console.log(1 || 0) // 1

// 按顺序计算
// 1 && 0 取 0， 0 && 1 取 0
console.log(1 && 0 && 1) // 0
// 0 && 1 取 0，0 && 1 取 0
console.log(0 && 1 && 1) // 0

console.log(1 && false && 1) // false
console.log(1 || false && false) // false

console.log(typeof false && 1) // 1
console.log(typeof '' && 1) // 1
console.log(typeof null && 1) // 1
console.log(1 && typeof true) // boolean
console.log(1 && typeof null) // object
```

# MVC和MVVM模式

MVC模式：
* M 模型（Model）：数据(js变量)
* V 视图（View）：用户界面(HTML,CSS)
* C 控制器（Controller）：事件交互、业务逻辑(DOM绑定事件，操作变量)

用户通过View传送指令到Controller，Controller完成业务逻辑，改变Model数据的状态，Model将新的状态反应到View视图上，用户得到反馈。

MVVM模式：

* M 模型（Model）：数据、变量
* V 视图（View）：用户界面
* VM （ViewModel）：实现数据的双向绑定，就是VUE，省去了DOM操作。
